# 탐욕 알고리즘 

### concept

탐욕 알고리즘이란 **매순간 최적이라고 생각되는 것ㅇ르 선택해** 나가는 방식으로 진행하여 `최종적인 최적해`에 도달하는 기법을 가리킵니다 

탐욕 알고리즘이 잘 작동하는 문제는 `greedy choice property`와 `optimal substructure` 두 가지 속성을 만족합니다 

전자의 경우 앞의 선택이 이후 선택에 영향을 주지 않는다는 걸 의미하고, 후자는 문제를 전체에 대한 최적해가 부분문제에 대해서도 역시 최적해가 된다는 걸 뜻합니다 

예를 들자면 `분할가능 배낭문제(Fractional knapsack problem)`가 대표적인 탐욕 알고리즘의 사례에 속합니다 
배낭문제는 한 여행가가 가지고 가는 배낭에 담을 수 있는 무게의 최댓값이 정해져 있고 일정 가치와 무게가 잇는 짐들을 배낭에 넣을 때
가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제입니다 

분할가능 배낭문제는 짐을 쪼갤 수 있는 경우에 해당됩니다 

분할가능 배낭문제는 단위 무게당 값어치가 가장 큰 짐을 먼저 넣으면 되는데, 순간순간의 선택이 이후 선택에 영향을 주지 않고 순간순간의 최적 선택이 전체 문제 최적해와 일치합니다

#### 따라서 분할가능 배낭문제는 탐욕 알고리즘으로 풀 수가 있습니다

반면 짐을 쪼갤 수 없는 배낭문제를 0-1 배낭문제(0-1 Knapsack Problem)라고 합니다

짐을 쪼갤 수 없기 때문에 가능한 모든 조합에 대해 일일이 따져본 후에 가치의 합이 최대가 되도록 하는 조합을 찾는 문제가 되는데, 

이 때는 동적계획법(dynamic programming)으로 문제를 풀게 됩니다

다시 말해 모든 경우의 수를 따져보되 중간계산 결과를 저장해 두었다가 이를 다시 써먹는 방식으로 계산량 감소를 유도하는 전략입니다

이 포스트에서는 탐욕 알고리즘의 대표 예시인 **Activity-Selection Problem**과 **Huffman Coding**에 대해 살펴보도록 하겠습니다

#### Activity-Selection Problem

교실할당로도 불립니다 한정된 교실 공간 내에서 최대 수업을 배정하는 문제입니다 9개의 수업이 있고 시작시간 s와 종료시간 f가 다음과 같이 주어졌다고 합시다 

![image](https://user-images.githubusercontent.com/80239748/156345252-4ad49b69-a3ba-4eb1-92e6-ae51b4f39cb2.png)

종료시간이 가장 빠른 수업을 배치하게 되면 교실 가용시간은 항상 최대가 됩니다 
종료시간이 빠른 수업부터 차례부터 배정하기 때문에 앞의 이후 선택에 변화를 주지 않고 매순간 선택이 항상 최적이 됩니다 

이 문제는 탐욕 알고리즘 속성을 만족한다는 이야기입니다

종료시간을 오름차순으로 정령해 수업을 배정하면 다음과 같은 그림이 됩니다 

![image](https://user-images.githubusercontent.com/80239748/156346781-bb26e4e9-bb4f-4996-9ffc-03372657b46c.png)

탐욕 알고리즘을 적용한 결과 한 교실에 배정할 수 있는 최대 수업의 조합은 a1,a3,a6,a8인 것을 확인할 수 있습니다 물론 a2,a5,a7,a8 또한 가능합니다만 a1을 기본 결과값으로 포함시킨 앞의 결과보다 더 나은 해라고 할 수는 없습니다

이 문제의 계산복잡도는 O(n)입니다 첫번째 수업을 기본 결과값으로 포함시키고 첫 수업과 나머지 n-1개 수업이 겹치는지 여부만 확인하면 되기 때문입니다