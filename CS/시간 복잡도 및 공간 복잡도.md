# 시간 복잡도(Time Complexity) 및 공간 복잡도(Space Complexity)

알고리즘을 평가할 때 시간 복잡도와 공간 복잡도를 사용합니다 

* 시간 복잡도:알고리즘의 수행시간을 평가 즉,연산횟수
* 공간 복잡도:알고리즘 수행에 필요한 메모리 양을 평가 즉,호출횟수 

시간 복잡도와 공간 복잡도는 주로 점근적 표기법 중 빅오 표기법을 이용하여 나타냅니다 

이유는 최악의 경우에도 해당 알고리즘이 어떤 성능을 낼지 가늠해볼 수 있기때문입니다 

## 시간 복잡도(Time Complexity)

알고리즘의 수행 시간을 분석할 때 시간 복잡도를 사용합니다 

기본 연산은 다음과 같습니다

1. 데이터 입출력 - copy, move...
2. 산술 연산 - add, multiply ...
3. 제어 연산 - if, while ...

시간 복잡도는 3가지 경우로 나타냅니다 

#### 1. 최선의 경우 (Best Case)

* 빅 오메가 표기법 사용 
* 최선의 시나리오로 최소 이만한 시간이 걸림

#### 2. 최악의 경우 (Worst Case)

* 빅 오 표기법 사용 
* 최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림 

#### 3.평균적인 경우 (Average Case)

* 빅 세타 표기법 사용
* 평균 시간을 나타냄

평균적인 경우를 가장 많이 사용할 것 같지만 알고리즘이 복잡해질수록 평균적인 경우는 구하기가 매우 어려줘 지기 때문에 `최악의 경우`로 알고리즘의 성능을 파악합니다 

## 시간 복잡도 계산 

시간 복잡도는 일반적으로 **빅오 표기법**으로 나타냅니다 
연산 횟수가 다항식으로 표현될 경우, 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시켜 나타냅니다 

$$T(n) = n^2 + 2n +1 =O(n^2)$$
: 최고차항만 나타냄
$$T(n) = 2n = O(n)$$
: 최고차항의 계수는 제외함

## 시간 복잡도 표기 

$ O(1) $- 상수 시간 (Constant time) 

입력 크기(n)에 상관없이 일정한 연산을 수행하면 시간복잡도는 O(1)입니다

$O(logN)$- 로그 시간 (Logarithmic time)

입력 크기(N)가 커질 때 연산 횟수가 logN에 비례해서 증가하면 시간 복잡도는 O(logN)입니다

$O(n)$- 선형 시간 (Linear time)

입력 크기(n)가 커질 때 연산 횟수가 n에 비례해서 증가하면 시간 복잡도는 O(n)입니다 

$O(n^2)$- 2차 시간 (Quadratic time)

입력 크기(n)가 커질 때 연산 횟수가 $n^2$에 비례해서 증가하면 시간 복잡도는 입니다.

$O(2^n)$-지수 시간 (Exponential time)

입력 크기가 커질 때 연산수가 $2^n$에 비례해서 증가하면 시간 복잡도는 $O(2^n)$입니다.



```
모든건 횟수 기준으로 
연습문제 
1. O(b)  입력 크기인 b에 따라 연산 횟수도 b에 비례 증가함에 따라 증가하기에 
2. O(b)
3. O(1) 위와 같은 이유 
4. O(a/b)
5. O(logn) : 절반씩 줄어듬 이진 탐색 N 자리가 1/2 씩 줄어들기때문에 
6. O(루트n) : guess의 제곱이 n 이기에 
7. O(array.lenght^2) : copyArray를 돌리면서 appendArray를 실행하기에 결국에는 이중for문과 같은 (a*b) 
8. O(logn) : 
9. O(n^k) : 반복한번 재귀에서 반복 한번 문자열이 늘어날수록 승이 늘어나기에 
10. O(nlog2 n) :  

for, while문은 n번까지 몇번 계산을 하는가
```